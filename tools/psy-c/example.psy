# Example Psy-C Schema
# This demonstrates the schema format for psy-c

namespace example.crypto;

# Simple message with field-level encryption
struct SecureMessage {
    # Unencrypted metadata
    id: uint64;
    timestamp: int64;
    
    # Encrypted fields
    content: bytes @encrypt(algorithm = "aes256") @compress(algorithm = "lz4");
    secret_key: bytes @encrypt(algorithm = "chacha20");
    
    # Optional field
    metadata: text? @compress(algorithm = "lz4");
}

# Nested structure with struct-level encryption and compression
@encrypt(algorithm = "aes256")
@compress(algorithm = "fpc")  # Use FPC for floating-point heavy data
struct EncryptedRecord {
    user_id: uint64;
    data: bytes;
    tags: list<text>;
}

# Complex example with authentication
struct AuthenticatedPacket {
    # Header is authenticated but not encrypted
    header: Header @authenticate(algorithm = "hmac_sha256");
    
    # Payload is encrypted and authenticated
    payload: bytes @encrypt(algorithm = "chacha20_poly1305");
}

# Example with digital signatures
@sign(algorithm = "ed25519")
struct SignedMessage {
    sender_id: uint64;
    timestamp: int64;
    message: text;
    attachments: list<bytes>?;
}

# Field-level signing
struct PartiallySignedDocument {
    # These fields are included in signature
    document_id: uint64 @sign;
    content: bytes @sign @compress(algorithm = "lz4");
    author: text @sign;
    
    # These fields are not signed (can be modified)
    view_count: uint32;
    last_accessed: int64;
    cached_preview: bytes?;
}

struct Header {
    version: uint8;
    flags: uint32;
    sender_id: uint64;
}

# Enum support
enum MessageType {
    PING = 0;
    PONG = 1;
    DATA = 2;
    CONTROL = 3;
}

# Union support (tagged union)
union Request {
    ping: PingRequest;
    data: DataRequest;
    control: ControlRequest;
}

struct PingRequest {
    sequence: uint32;
}

struct DataRequest {
    payload: bytes @encrypt(algorithm = "aes256");
    checksum: uint32;
}

struct ControlRequest {
    command: uint16;
    parameters: map<text, bytes>;
}

# List and map examples
struct Collection {
    numbers: list<int32>;
    strings: list<text>;
    lookup: map<text, uint64>;
    
    # Encrypted collections
    secrets: list<bytes> @encrypt(algorithm = "aes256");
}