/**
 * @file test_full_pipeline.cpp
 * @brief Test the full psy-c pipeline: serialize -> compress -> encrypt
 */

#include <iostream>
#include <iomanip>
#include <chrono>
#include <psyfer.hpp>
#include <psyfer/serialization/psy_runtime.hpp>

// This would normally be generated by psy-c
namespace example::crypto {

struct Message {
    uint64_t id;
    std::vector<std::byte> data;
    std::string metadata;
    
    // Serialization
    [[nodiscard]] size_t serialized_size() const noexcept {
        using namespace psyfer::serialization;
        return field_header_size(1) + 8 +  // id
               field_header_size(2) + bytes_field_size(data.size()) +  // data
               field_header_size(3) + string_field_size(metadata);     // metadata
    }
    
    [[nodiscard]] size_t serialize(std::span<std::byte> buffer) const noexcept {
        using namespace psyfer::serialization;
        BufferWriter writer(buffer);
        
        writer.write_field_header(1, WireType::FIXED64);
        writer.write_u64(id);
        
        writer.write_field_header(2, WireType::BYTES);
        writer.write_bytes_field(data);
        
        writer.write_field_header(3, WireType::BYTES);
        writer.write_string_field(metadata);
        
        return writer.position();
    }
    
    // Compression
    [[nodiscard]] size_t compressed_size() const noexcept {
        psyfer::compression::lz4 compressor;
        return compressor.max_compressed_size(serialized_size());
    }
    
    [[nodiscard]] size_t compress(std::span<std::byte> buffer) const noexcept {
        // First serialize to temp buffer
        std::vector<std::byte> temp(serialized_size());
        size_t ser_size = serialize(temp);
        
        // Then compress
        psyfer::compression::lz4 compressor;
        auto result = compressor.compress(
            std::span(temp.data(), ser_size),
            buffer
        );
        
        if (!result) {
            std::cerr << "LZ4 compression error: " << result.error().message() << "\n";
            return 0;
        }
        
        return *result;
    }
    
    // Encryption (after compression)
    [[nodiscard]] size_t encrypted_size() const noexcept {
        return compressed_size() + 12 + 16;  // +nonce +tag
    }
    
    [[nodiscard]] size_t encrypt_compressed(
        std::span<std::byte> buffer,
        std::span<const std::byte> key
    ) const noexcept {
        // Layout: [nonce:12][encrypted_compressed_data][tag:16]
        
        // First compress
        auto compressed_start = buffer.subspan(12);
        size_t compressed_size = compress(compressed_start);
        
        if (compressed_size == 0) {
            std::cerr << "Compression failed!\n";
            return 0;
        }
        
        // Generate nonce
        auto nonce = buffer.subspan(0, 12);
        psyfer::utils::secure_random::generate(nonce);
        
        // Encrypt compressed data in-place
        auto tag = buffer.subspan(12 + compressed_size, 16);
        auto result = psyfer::crypto::aes256_gcm::encrypt_oneshot(
            compressed_start.subspan(0, compressed_size),
            std::span<const std::byte, 32>(key.data(), 32),
            std::span<const std::byte, 12>(nonce.data(), 12),
            std::span<std::byte, 16>(tag.data(), 16),
            {}  // no AAD
        );
        
        if (result != psyfer::error_code::success) {
            return 0;
        }
        
        return 12 + compressed_size + 16;
    }
    
    // The complete pipeline in reverse
    [[nodiscard]] static std::optional<Message> decrypt_decompress_deserialize(
        std::span<const std::byte> buffer,
        std::span<const std::byte> key
    ) noexcept {
        if (buffer.size() < 28) return std::nullopt;  // min size
        
        // Extract components
        auto nonce = buffer.subspan(0, 12);
        auto tag = buffer.subspan(buffer.size() - 16, 16);
        auto encrypted = buffer.subspan(12, buffer.size() - 28);
        
        // Decrypt
        std::vector<std::byte> compressed(encrypted.size());
        std::memcpy(compressed.data(), encrypted.data(), encrypted.size());
        
        auto decrypt_result = psyfer::crypto::aes256_gcm::decrypt_oneshot(
            compressed,
            std::span<const std::byte, 32>(key.data(), 32),
            std::span<const std::byte, 12>(nonce.data(), 12),
            std::span<const std::byte, 16>(tag.data(), 16),
            {}  // no AAD
        );
        
        if (decrypt_result != psyfer::error_code::success) {
            std::cerr << "Decryption failed with error: " << static_cast<int>(decrypt_result.value()) << "\n";
            return std::nullopt;
        }
        
        // Decompress
        psyfer::compression::lz4 decompressor;
        std::vector<std::byte> decompressed(compressed.size() * 10);
        auto decomp_result = decompressor.decompress(compressed, decompressed);
        if (!decomp_result) return std::nullopt;
        
        // Deserialize
        using namespace psyfer::serialization;
        BufferReader reader(std::span(decompressed.data(), *decomp_result));
        Message msg;
        
        while (reader.remaining() > 0) {
            auto header = reader.read_field_header();
            if (!header) break;
            
            switch (header->field_number) {
            case 1:  // id
                if (auto val = reader.read_u64()) {
                    msg.id = *val;
                }
                break;
            case 2:  // data
                if (auto data = reader.read_bytes_field()) {
                    msg.data.assign(data->begin(), data->end());
                }
                break;
            case 3:  // metadata
                if (auto str = reader.read_string_field()) {
                    msg.metadata = std::string(*str);
                }
                break;
            default:
                // Skip unknown fields
                break;
            }
        }
        
        return msg;
    }
};

} // namespace example::crypto

void print_size_comparison(const example::crypto::Message& msg) {
    size_t original_size = msg.serialized_size();
    size_t compressed_size = msg.compressed_size();
    size_t encrypted_size = msg.encrypted_size();
    
    std::cout << "\nSize comparison:\n";
    std::cout << "  Serialized: " << original_size << " bytes\n";
    std::cout << "  Compressed: " << compressed_size << " bytes (max)\n";
    std::cout << "  Encrypted: " << encrypted_size << " bytes (compressed + encrypted)\n";
}

int main() {
    using namespace example::crypto;
    
    std::cout << "=== Psy-C Full Pipeline Test ===\n";
    std::cout << "Pipeline: Serialize -> Compress -> Encrypt\n\n";
    
    // Create test message
    Message msg;
    msg.id = 42;
    msg.metadata = "This is a test message with some metadata that should compress well. "
                   "Repeated text repeated text repeated text repeated text.";
    
    // Add some compressible data
    msg.data.resize(1000);
    for (size_t i = 0; i < msg.data.size(); ++i) {
        msg.data[i] = static_cast<std::byte>(i % 100);  // Repeating pattern
    }
    
    std::cout << "Original message:\n";
    std::cout << "  ID: " << msg.id << "\n";
    std::cout << "  Data size: " << msg.data.size() << " bytes\n";
    std::cout << "  Metadata: \"" << msg.metadata << "\"\n";
    
    print_size_comparison(msg);
    
    // Generate encryption key
    std::array<std::byte, 32> key;
    psyfer::utils::secure_random::generate(key);
    
    // Full pipeline: serialize -> compress -> encrypt
    std::vector<std::byte> encrypted(msg.encrypted_size());
    size_t final_size = msg.encrypt_compressed(encrypted, key);
    encrypted.resize(final_size);
    
    std::cout << "\nDebug info:\n";
    std::cout << "  Nonce at [0:12]\n";
    std::cout << "  Encrypted data at [12:" << (final_size - 16) << "]\n";
    std::cout << "  Tag at [" << (final_size - 16) << ":" << final_size << "]\n";
    
    std::cout << "\nActual compressed+encrypted size: " << final_size << " bytes\n";
    std::cout << "Compression ratio: " << std::fixed << std::setprecision(2) 
              << (1.0 - double(final_size) / double(msg.serialized_size())) * 100 << "%\n";
    
    // Reverse pipeline: decrypt -> decompress -> deserialize
    auto decrypted_msg = Message::decrypt_decompress_deserialize(encrypted, key);
    
    if (decrypted_msg) {
        std::cout << "\nDecrypted message:\n";
        std::cout << "  ID: " << decrypted_msg->id << "\n";
        std::cout << "  Data size: " << decrypted_msg->data.size() << " bytes\n";
        std::cout << "  Metadata: \"" << decrypted_msg->metadata << "\"\n";
        
        // Verify
        bool data_matches = std::equal(msg.data.begin(), msg.data.end(), 
                                     decrypted_msg->data.begin());
        std::cout << "\nVerification: " 
                  << (decrypted_msg->id == msg.id && 
                      data_matches && 
                      decrypted_msg->metadata == msg.metadata ? "PASSED" : "FAILED")
                  << "\n";
    } else {
        std::cout << "\nDecryption/decompression failed!\n";
    }
    
    // Performance test
    std::cout << "\n--- Performance Test ---\n";
    const int iterations = 10000;
    
    auto start = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < iterations; ++i) {
        std::vector<std::byte> buf(msg.encrypted_size());
        msg.encrypt_compressed(buf, key);
    }
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    
    std::cout << "Serialize+Compress+Encrypt performance:\n";
    std::cout << "  " << iterations << " iterations in " << duration.count() << " µs\n";
    std::cout << "  " << (duration.count() / iterations) << " µs per operation\n";
    std::cout << "  " << (iterations * 1000000.0 / duration.count()) << " ops/sec\n";
    
    double throughput_mb = (msg.data.size() + msg.metadata.size()) * iterations / 
                          (duration.count() / 1000000.0) / (1024 * 1024);
    std::cout << "  Throughput: " << throughput_mb << " MB/s\n";
    
    return 0;
}