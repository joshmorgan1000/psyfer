/**
 * @file code_generator.cpp
 * @brief C++ code generator implementation
 */

#include "psy-c/code_generator.hpp"
#include <algorithm>
#include <cctype>
#include <functional>

namespace psyc {

std::string CodeGenerator::generate(const Schema& schema, const GeneratorOptions& options) {
    CodeGenerator gen(schema, options);
    return gen.generate_code();
}

CodeGenerator::CodeGenerator(const Schema& schema, const GeneratorOptions& options)
    : schema_(schema), options_(options) {}

std::string CodeGenerator::generate_code() {
    generate_header();
    generate_includes();
    generate_namespace_begin();
    generate_forward_declarations();
    generate_enums();
    generate_structs();
    generate_unions();
    generate_namespace_end();
    
    return output_.str();
}

void CodeGenerator::generate_header() {
    emit_line("/**");
    emit_line(" * @file generated.hpp");
    emit_line(" * @brief Generated by psy-c from schema");
    emit_line(" * @warning This file is auto-generated. Do not edit manually.");
    emit_line(" */");
    emit_line();
    
    // Header guard
    std::string guard = options_.header_guard_prefix + "_";
    if (schema_.namespace_decl) {
        std::string ns = (*schema_.namespace_decl)->to_string();
        std::replace(ns.begin(), ns.end(), '.', '_');
        std::transform(ns.begin(), ns.end(), ns.begin(), ::toupper);
        guard += ns + "_";
    }
    guard += "HPP";
    
    emit_line("#pragma once");
    emit_line();
}

void CodeGenerator::generate_includes() {
    emit_line("#include <psyfer.hpp>");
    emit_line("#include <array>");
    emit_line("#include <cstdint>");
    emit_line("#include <memory>");
    emit_line("#include <span>");
    emit_line("#include <string>");
    emit_line("#include <variant>");
    emit_line("#include <vector>");
    emit_line("#include <map>");
    emit_line("#include <optional>");
    emit_line();
}

void CodeGenerator::generate_namespace_begin() {
    if (options_.namespace_prefix.empty() && !schema_.namespace_decl) {
        return;
    }
    
    if (!options_.namespace_prefix.empty()) {
        emit_line("namespace " + options_.namespace_prefix + " {");
    }
    
    if (schema_.namespace_decl) {
        for (const auto& component : (*schema_.namespace_decl)->components) {
            emit_line("namespace " + component + " {");
        }
    }
    
    emit_line();
}

void CodeGenerator::generate_namespace_end() {
    if (schema_.namespace_decl) {
        for (size_t i = 0; i < (*schema_.namespace_decl)->components.size(); ++i) {
            emit_line("} // namespace " + (*schema_.namespace_decl)->components[
                (*schema_.namespace_decl)->components.size() - 1 - i]);
        }
    }
    
    if (!options_.namespace_prefix.empty()) {
        emit_line("} // namespace " + options_.namespace_prefix);
    }
}

void CodeGenerator::generate_forward_declarations() {
    // Forward declare all structs and unions
    for (const auto& st : schema_.structs) {
        emit_line("struct " + st->name + ";");
        forward_declared_.insert(st->name);
    }
    
    for (const auto& un : schema_.unions) {
        emit_line("struct " + un->name + ";");
        forward_declared_.insert(un->name);
    }
    
    if (!schema_.structs.empty() || !schema_.unions.empty()) {
        emit_line();
    }
}

void CodeGenerator::generate_enums() {
    for (const auto& en : schema_.enums) {
        generate_enum(*en);
        emit_line();
    }
}

void CodeGenerator::generate_enum(const Enum& en) {
    if (options_.generate_comments) {
        emit_comment("Enum: " + en.name);
    }
    
    emit_line("enum class " + en.name + " : int32_t {");
    indent();
    
    for (size_t i = 0; i < en.values.size(); ++i) {
        const auto& val = en.values[i];
        emit(val->name + " = " + std::to_string(val->value));
        if (i < en.values.size() - 1) {
            emit(",");
        }
        emit_line();
    }
    
    dedent();
    emit_line("};");
}

void CodeGenerator::generate_structs() {
    // Sort structs by dependencies
    auto sorted_structs = topological_sort_structs();
    
    for (const auto& st : sorted_structs) {
        generate_struct(*st);
        emit_line();
    }
}

void CodeGenerator::generate_struct(const Struct& st) {
    if (options_.generate_comments) {
        emit_comment("Struct: " + st.name);
        if (st.is_encrypted()) {
            emit_comment("@encrypted");
        }
    }
    
    emit_line("struct " + st.name + " {");
    indent();
    
    // Generate fields
    for (const auto& field : st.fields) {
        generate_field(*field, st.name);
    }
    
    // Generate methods
    emit_line();
    emit_comment("Serialization methods");
    
    // Size calculation
    emit_line("[[nodiscard]] size_t serialized_size() const noexcept;");
    
    // Serialization
    emit_line("[[nodiscard]] size_t serialize(std::span<std::byte> buffer) const noexcept;");
    emit_line("[[nodiscard]] std::vector<std::byte> serialize() const;");
    
    // Deserialization
    emit_line("[[nodiscard]] static std::optional<" + st.name + "> deserialize(std::span<const std::byte> buffer) noexcept;");
    emit_line("[[nodiscard]] static size_t deserialize(");
    indent();
    emit_line("std::span<const std::byte> source_buffer,");
    emit_line(st.name + "* target");
    dedent();
    emit_line(") noexcept;");
    
    // Encryption methods if needed
    if (needs_encryption(st)) {
        generate_encryption_methods(st);
    }
    
    // Compression methods if needed
    if (needs_compression(st)) {
        generate_compression_methods(st);
    }
    
    // Signing methods if needed
    if (needs_signing(st)) {
        generate_signing_methods(st);
    }
    
    dedent();
    emit_line("};");
}

void CodeGenerator::generate_field(const Field& field, const std::string& struct_name) {
    if (options_.generate_comments) {
        std::string comment;
        if (field.has_annotation("encrypt")) {
            comment += "@encrypted(" + encryption_algorithm(field.get_annotation("encrypt")) + ")";
        }
        if (field.has_annotation("compress")) {
            if (!comment.empty()) comment += " ";
            comment += "@compress(" + compression_algorithm(field.get_annotation("compress")) + ")";
        }
        if (!comment.empty()) {
            emit_comment(comment);
        }
    }
    
    emit_line(cpp_type_name(field.type) + " " + field.name + ";");
}

void CodeGenerator::generate_unions() {
    for (const auto& un : schema_.unions) {
        generate_union(*un);
        emit_line();
    }
}

void CodeGenerator::generate_union(const Union& un) {
    if (options_.generate_comments) {
        emit_comment("Tagged union: " + un.name);
    }
    
    emit_line("struct " + un.name + " {");
    indent();
    
    // Generate tag enum
    emit_line("enum class Tag : uint16_t {");
    indent();
    for (size_t i = 0; i < un.members.size(); ++i) {
        emit(sanitize_identifier(un.members[i]->name) + " = " + std::to_string(i));
        if (i < un.members.size() - 1) {
            emit(",");
        }
        emit_line();
    }
    dedent();
    emit_line("};");
    emit_line();
    
    // Generate variant
    emit("using Value = std::variant<");
    for (size_t i = 0; i < un.members.size(); ++i) {
        if (i > 0) emit(", ");
        emit(un.members[i]->type_name);
    }
    emit_line(">;");
    emit_line();
    
    // Fields
    emit_line("Tag tag;");
    emit_line("Value value;");
    emit_line();
    
    // Helper methods
    for (const auto& member : un.members) {
        std::string name = member->name;
        std::string type = member->type_name;
        
        // Getter
        emit_line("[[nodiscard]] " + type + "* get_" + name + "() noexcept {");
        indent();
        emit_line("return tag == Tag::" + sanitize_identifier(name) + 
                  " ? std::get_if<" + type + ">(&value) : nullptr;");
        dedent();
        emit_line("}");
        
        // Const getter
        emit_line("[[nodiscard]] const " + type + "* get_" + name + "() const noexcept {");
        indent();
        emit_line("return tag == Tag::" + sanitize_identifier(name) + 
                  " ? std::get_if<" + type + ">(&value) : nullptr;");
        dedent();
        emit_line("}");
        emit_line();
    }
    
    // Serialization methods
    emit_line("[[nodiscard]] size_t serialized_size() const noexcept;");
    emit_line("[[nodiscard]] size_t serialize(std::span<std::byte> buffer) const noexcept;");
    emit_line("[[nodiscard]] static std::optional<" + un.name + "> deserialize(std::span<const std::byte> buffer) noexcept;");
    emit_line("[[nodiscard]] static size_t deserialize(");
    indent();
    emit_line("std::span<const std::byte> source_buffer,");
    emit_line(un.name + "* target");
    dedent();
    emit_line(") noexcept;");
    
    dedent();
    emit_line("};");
}

std::string CodeGenerator::cpp_type_name(const Type& type) const {
    std::string base_type;
    
    if (type.is_primitive()) {
        base_type = primitive_type_name(std::get<PrimitiveType>(type.kind));
    } else if (type.is_named()) {
        base_type = std::get<std::string>(type.kind);
    } else if (type.is_list()) {
        auto element_type = std::get<std::shared_ptr<Type>>(type.kind);
        base_type = "std::vector<" + cpp_type_name(*element_type) + ">";
    } else if (type.is_map()) {
        auto [key_type, value_type] = std::get<std::pair<std::shared_ptr<Type>, 
                                                         std::shared_ptr<Type>>>(type.kind);
        base_type = "std::map<" + cpp_type_name(*key_type) + ", " + 
                    cpp_type_name(*value_type) + ">";
    }
    
    if (type.optional) {
        return "std::optional<" + base_type + ">";
    }
    
    return base_type;
}

std::string CodeGenerator::primitive_type_name(PrimitiveType type) const {
    switch (type) {
        case PrimitiveType::BOOL: return "bool";
        case PrimitiveType::INT8: return "int8_t";
        case PrimitiveType::INT16: return "int16_t";
        case PrimitiveType::INT32: return "int32_t";
        case PrimitiveType::INT64: return "int64_t";
        case PrimitiveType::UINT8: return "uint8_t";
        case PrimitiveType::UINT16: return "uint16_t";
        case PrimitiveType::UINT32: return "uint32_t";
        case PrimitiveType::UINT64: return "uint64_t";
        case PrimitiveType::FLOAT32: return "float";
        case PrimitiveType::FLOAT64: return "double";
        case PrimitiveType::BYTES: return "std::vector<std::byte>";
        case PrimitiveType::TEXT: return "std::string";
    }
    return "unknown";
}

void CodeGenerator::generate_encryption_methods(const Struct& st) {
    emit_line();
    emit_comment("Encryption methods");
    
    // Encrypt method
    emit_line("[[nodiscard]] size_t encrypted_size() const noexcept;");
    emit_line("[[nodiscard]] size_t encrypt(");
    indent();
    emit_line("std::span<std::byte> buffer,");
    emit_line("std::span<const std::byte> key");
    dedent();
    emit_line(") const noexcept;");
    
    emit_line("[[nodiscard]] std::vector<std::byte> encrypt(");
    indent();
    emit_line("std::span<const std::byte> key");
    dedent();
    emit_line(") const;");
    
    // Decrypt method
    emit_line("[[nodiscard]] static std::optional<" + st.name + "> decrypt(");
    indent();
    emit_line("std::span<const std::byte> buffer,");
    emit_line("std::span<const std::byte> key");
    dedent();
    emit_line(") noexcept;");
    
    emit_line("[[nodiscard]] static size_t decrypt(");
    indent();
    emit_line("std::span<const std::byte> source_buffer,");
    emit_line(st.name + "* target,");
    emit_line("std::span<const std::byte> key");
    dedent();
    emit_line(") noexcept;");
}

bool CodeGenerator::needs_encryption(const Struct& st) const {
    // Check struct-level encryption
    if (st.is_encrypted()) {
        return true;
    }
    
    // Check field-level encryption
    for (const auto& field : st.fields) {
        if (field->has_annotation("encrypt")) {
            return true;
        }
    }
    
    return false;
}

std::string CodeGenerator::encryption_algorithm(const Annotation* ann) const {
    if (!ann) return "aes256";
    
    auto algo = ann->get_parameter("algorithm");
    return algo.value_or("aes256");
}

void CodeGenerator::generate_compression_methods(const Struct& st) {
    emit_line();
    emit_comment("Compression methods");
    
    // Compress method
    emit_line("[[nodiscard]] size_t compressed_size() const noexcept;");
    emit_line("[[nodiscard]] size_t compress(");
    indent();
    emit_line("std::span<std::byte> buffer");
    dedent();
    emit_line(") const noexcept;");
    
    emit_line("[[nodiscard]] std::vector<std::byte> compress() const;");
    
    // Decompress method
    emit_line("[[nodiscard]] static std::optional<" + st.name + "> decompress(");
    indent();
    emit_line("std::span<const std::byte> buffer");
    dedent();
    emit_line(") noexcept;");
    
    emit_line("[[nodiscard]] static size_t decompress(");
    indent();
    emit_line("std::span<const std::byte> source_buffer,");
    emit_line(st.name + "* target");
    dedent();
    emit_line(") noexcept;");
}

bool CodeGenerator::needs_compression(const Struct& st) const {
    // Check struct-level compression
    if (st.has_annotation("compress")) {
        return true;
    }
    
    // Check field-level compression
    for (const auto& field : st.fields) {
        if (field->has_annotation("compress")) {
            return true;
        }
    }
    
    return false;
}

std::string CodeGenerator::compression_algorithm(const Annotation* ann) const {
    if (!ann) return "lz4";
    
    auto algo = ann->get_parameter("algorithm");
    return algo.value_or("lz4");
}

void CodeGenerator::generate_signing_methods(const Struct& st) {
    emit_line();
    emit_comment("Digital signature methods");
    
    // Sign method
    emit_line("[[nodiscard]] std::array<std::byte, 64> sign(");
    indent();
    emit_line("std::span<const std::byte, 32> private_key");
    dedent();
    emit_line(") const noexcept;");
    
    // Verify method
    emit_line("[[nodiscard]] static bool verify(");
    indent();
    emit_line("const " + st.name + "& message,");
    emit_line("std::span<const std::byte, 64> signature,");
    emit_line("std::span<const std::byte, 32> public_key");
    dedent();
    emit_line(") noexcept;");
    
    // Sign with embedded signature
    emit_line("[[nodiscard]] std::vector<std::byte> sign_and_serialize(");
    indent();
    emit_line("std::span<const std::byte, 32> private_key");
    dedent();
    emit_line(") const;");
    
    // Verify and deserialize
    emit_line("[[nodiscard]] static std::optional<" + st.name + "> verify_and_deserialize(");
    indent();
    emit_line("std::span<const std::byte> signed_data,");
    emit_line("std::span<const std::byte, 32> public_key");
    dedent();
    emit_line(") noexcept;");
}

bool CodeGenerator::needs_signing(const Struct& st) const {
    // Check struct-level signing
    if (st.has_annotation("sign")) {
        return true;
    }
    
    // Check field-level signing
    for (const auto& field : st.fields) {
        if (field->has_annotation("sign")) {
            return true;
        }
    }
    
    return false;
}

std::string CodeGenerator::signing_algorithm(const Annotation* ann) const {
    if (!ann) return "ed25519";
    
    auto algo = ann->get_parameter("algorithm");
    return algo.value_or("ed25519");
}

void CodeGenerator::emit(const std::string& text) {
    output_ << text;
}

void CodeGenerator::emit_line(const std::string& text) {
    for (size_t i = 0; i < indent_level_; ++i) {
        output_ << "    ";
    }
    output_ << text << "\n";
}

void CodeGenerator::indent() {
    indent_level_++;
}

void CodeGenerator::dedent() {
    if (indent_level_ > 0) {
        indent_level_--;
    }
}

void CodeGenerator::emit_comment(const std::string& text) {
    emit_line("/**");
    emit_line(" * @brief " + text);
    emit_line(" */");
}

std::string CodeGenerator::sanitize_identifier(const std::string& id) const {
    std::string result = id;
    std::transform(result.begin(), result.end(), result.begin(), ::toupper);
    return result;
}

std::vector<const Struct*> CodeGenerator::topological_sort_structs() const {
    std::vector<const Struct*> result;
    std::set<std::string> visited;
    std::set<std::string> visiting;
    
    std::function<void(const Struct*)> visit = 
        [&](const Struct* st) {
        if (visited.count(st->name)) return;
        if (visiting.count(st->name)) {
            // Circular dependency - just proceed
            return;
        }
        
        visiting.insert(st->name);
        
        // Visit dependencies first
        std::set<std::string> deps;
        collect_struct_dependencies(*st, deps);
        
        for (const auto& dep : deps) {
            // Find the struct with this name
            for (const auto& other : schema_.structs) {
                if (other->name == dep) {
                    visit(other.get());
                    break;
                }
            }
        }
        
        visiting.erase(st->name);
        visited.insert(st->name);
        result.push_back(st);
    };
    
    // Visit all structs
    for (const auto& st : schema_.structs) {
        visit(st.get());
    }
    
    return result;
}

void CodeGenerator::collect_struct_dependencies(const Struct& st, std::set<std::string>& deps) const {
    for (const auto& field : st.fields) {
        if (field->type.is_named()) {
            auto type_name = std::get<std::string>(field->type.kind);
            // Check if this is a struct (not an enum)
            for (const auto& other : schema_.structs) {
                if (other->name == type_name) {
                    deps.insert(type_name);
                    break;
                }
            }
        } else if (field->type.is_list()) {
            auto element_type = std::get<std::shared_ptr<Type>>(field->type.kind);
            if (element_type->is_named()) {
                auto type_name = std::get<std::string>(element_type->kind);
                for (const auto& other : schema_.structs) {
                    if (other->name == type_name) {
                        deps.insert(type_name);
                        break;
                    }
                }
            }
        } else if (field->type.is_map()) {
            auto [key_type, value_type] = std::get<std::pair<std::shared_ptr<Type>, 
                                                             std::shared_ptr<Type>>>(field->type.kind);
            if (value_type->is_named()) {
                auto type_name = std::get<std::string>(value_type->kind);
                for (const auto& other : schema_.structs) {
                    if (other->name == type_name) {
                        deps.insert(type_name);
                        break;
                    }
                }
            }
        }
    }
}

} // namespace psyc