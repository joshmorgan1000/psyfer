/**
 * @file generated.hpp
 * @brief Generated by psy-c from schema
 * @warning This file is auto-generated. Do not edit manually.
 */

#pragma once

#include <psyfer.hpp>
#include <array>
#include <cstdint>
#include <memory>
#include <span>
#include <string>
#include <variant>
#include <vector>
#include <map>
#include <optional>

namespace crypto_integration_test {

struct SecureMessage;
struct SecureDocument;
struct UserData;
struct AuthenticatedData;
struct IntegrityProtectedConfig;

/**
 * @brief Struct: SecureMessage
 */
/**
 * @brief @encrypted
 */
struct SecureMessage {
    uint64_t message_id;
    std::string sender;
    std::string content;
    uint64_t timestamp;
    
    /**
     * @brief Serialization methods
     */
    [[nodiscard]] size_t serialized_size() const noexcept;
    [[nodiscard]] size_t serialize(std::span<std::byte> buffer) const noexcept;
    [[nodiscard]] std::vector<std::byte> serialize() const;
    [[nodiscard]] static std::optional<SecureMessage> deserialize(std::span<const std::byte> buffer) noexcept;
    [[nodiscard]] static size_t deserialize(
        std::span<const std::byte> source_buffer,
        SecureMessage* target
    ) noexcept;
    
    /**
     * @brief Encryption methods
     */
    [[nodiscard]] size_t encrypted_size() const noexcept;
    [[nodiscard]] size_t encrypt(
        std::span<std::byte> buffer,
        std::span<const std::byte> key
    ) const noexcept;
    [[nodiscard]] std::vector<std::byte> encrypt(
        std::span<const std::byte> key
    ) const;
    [[nodiscard]] static std::optional<SecureMessage> decrypt(
        std::span<const std::byte> buffer,
        std::span<const std::byte> key
    ) noexcept;
    [[nodiscard]] static size_t decrypt(
        std::span<const std::byte> source_buffer,
        SecureMessage* target,
        std::span<const std::byte> key
    ) noexcept;
};

/**
 * @brief Struct: SecureDocument
 */
/**
 * @brief @encrypted
 */
struct SecureDocument {
    std::string doc_id;
    std::string title;
    /**
     * @brief @compress(lz4)
     */
    std::vector<std::byte> body;
    uint32_t version;
    
    /**
     * @brief Serialization methods
     */
    [[nodiscard]] size_t serialized_size() const noexcept;
    [[nodiscard]] size_t serialize(std::span<std::byte> buffer) const noexcept;
    [[nodiscard]] std::vector<std::byte> serialize() const;
    [[nodiscard]] static std::optional<SecureDocument> deserialize(std::span<const std::byte> buffer) noexcept;
    [[nodiscard]] static size_t deserialize(
        std::span<const std::byte> source_buffer,
        SecureDocument* target
    ) noexcept;
    
    /**
     * @brief Encryption methods
     */
    [[nodiscard]] size_t encrypted_size() const noexcept;
    [[nodiscard]] size_t encrypt(
        std::span<std::byte> buffer,
        std::span<const std::byte> key
    ) const noexcept;
    [[nodiscard]] std::vector<std::byte> encrypt(
        std::span<const std::byte> key
    ) const;
    [[nodiscard]] static std::optional<SecureDocument> decrypt(
        std::span<const std::byte> buffer,
        std::span<const std::byte> key
    ) noexcept;
    [[nodiscard]] static size_t decrypt(
        std::span<const std::byte> source_buffer,
        SecureDocument* target,
        std::span<const std::byte> key
    ) noexcept;
    
    /**
     * @brief Compression methods
     */
    [[nodiscard]] size_t compressed_size() const noexcept;
    [[nodiscard]] size_t compress(
        std::span<std::byte> buffer
    ) const noexcept;
    [[nodiscard]] std::vector<std::byte> compress() const;
    [[nodiscard]] static std::optional<SecureDocument> decompress(
        std::span<const std::byte> buffer
    ) noexcept;
    [[nodiscard]] static size_t decompress(
        std::span<const std::byte> source_buffer,
        SecureDocument* target
    ) noexcept;
};

/**
 * @brief Struct: UserData
 */
struct UserData {
    uint64_t user_id;
    /**
     * @brief @encrypted(aes256)
     */
    std::string api_key;
    /**
     * @brief @encrypted(chacha20)
     */
    std::string private_notes;
    std::string password;
    /**
     * @brief @compress(lz4)
     */
    std::vector<std::byte> avatar;
    /**
     * @brief @compress(fpc)
     */
    std::vector<double> metrics;
    
    /**
     * @brief Serialization methods
     */
    [[nodiscard]] size_t serialized_size() const noexcept;
    [[nodiscard]] size_t serialize(std::span<std::byte> buffer) const noexcept;
    [[nodiscard]] std::vector<std::byte> serialize() const;
    [[nodiscard]] static std::optional<UserData> deserialize(std::span<const std::byte> buffer) noexcept;
    [[nodiscard]] static size_t deserialize(
        std::span<const std::byte> source_buffer,
        UserData* target
    ) noexcept;
    
    /**
     * @brief Encryption methods
     */
    [[nodiscard]] size_t encrypted_size() const noexcept;
    [[nodiscard]] size_t encrypt(
        std::span<std::byte> buffer,
        std::span<const std::byte> key
    ) const noexcept;
    [[nodiscard]] std::vector<std::byte> encrypt(
        std::span<const std::byte> key
    ) const;
    [[nodiscard]] static std::optional<UserData> decrypt(
        std::span<const std::byte> buffer,
        std::span<const std::byte> key
    ) noexcept;
    [[nodiscard]] static size_t decrypt(
        std::span<const std::byte> source_buffer,
        UserData* target,
        std::span<const std::byte> key
    ) noexcept;
    
    /**
     * @brief Compression methods
     */
    [[nodiscard]] size_t compressed_size() const noexcept;
    [[nodiscard]] size_t compress(
        std::span<std::byte> buffer
    ) const noexcept;
    [[nodiscard]] std::vector<std::byte> compress() const;
    [[nodiscard]] static std::optional<UserData> decompress(
        std::span<const std::byte> buffer
    ) noexcept;
    [[nodiscard]] static size_t decompress(
        std::span<const std::byte> source_buffer,
        UserData* target
    ) noexcept;
};

/**
 * @brief Struct: AuthenticatedData
 */
struct AuthenticatedData {
    uint64_t sequence;
    std::vector<std::byte> data;
    uint64_t timestamp;
    
    /**
     * @brief Serialization methods
     */
    [[nodiscard]] size_t serialized_size() const noexcept;
    [[nodiscard]] size_t serialize(std::span<std::byte> buffer) const noexcept;
    [[nodiscard]] std::vector<std::byte> serialize() const;
    [[nodiscard]] static std::optional<AuthenticatedData> deserialize(std::span<const std::byte> buffer) noexcept;
    [[nodiscard]] static size_t deserialize(
        std::span<const std::byte> source_buffer,
        AuthenticatedData* target
    ) noexcept;
};

/**
 * @brief Struct: IntegrityProtectedConfig
 */
struct IntegrityProtectedConfig {
    uint32_t version;
    std::map<std::string, std::string> settings;
    uint64_t last_modified;
    
    /**
     * @brief Serialization methods
     */
    [[nodiscard]] size_t serialized_size() const noexcept;
    [[nodiscard]] size_t serialize(std::span<std::byte> buffer) const noexcept;
    [[nodiscard]] std::vector<std::byte> serialize() const;
    [[nodiscard]] static std::optional<IntegrityProtectedConfig> deserialize(std::span<const std::byte> buffer) noexcept;
    [[nodiscard]] static size_t deserialize(
        std::span<const std::byte> source_buffer,
        IntegrityProtectedConfig* target
    ) noexcept;
};

} // namespace crypto_integration_test
